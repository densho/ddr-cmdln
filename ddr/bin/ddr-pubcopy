#!/usr/bin/env python
#
# This file is part of ddr-cmdln/ddr
#
#  

description = """Copies binaries from a collection into a destination directory for publication."""

epilog = """
This command copies specified types of binaries from a collection to a
destination folder.  Destination files are in a very simple hierarchy (just
files within a single directory per collection) that is suitable for use by
ddr-public.

ddr-pubcopy produces a very simple file layout:

    $BASE/$COLLECTION_ID/$FILENAME

IMPORTANT: You are responsible for making sure that the destination base
directory is available and writable.

IMPORTANT: This command does not check whether files are published!
Use *after* filtering a collection.

EXAMPLES

     $ ddr-pubcopy -mtM /var/www/media/ddr/ddr-test-123 /media/USBHARDDRIVE

ddr-public - ddr-pubcopy"""

import argparse
from datetime import datetime
import logging
import os
import sys

import envoy

from DDR import config
from DDR import fileio
from DDR import identifier
from DDR import util


def dtfmt(dt):
    """Consistent date format.
    """
    return dt.strftime('%Y-%m-%dT%H:%M:%S.%f')

def logprint(filename, msg):
    """Print to log file and console, with timestamp.
    """
    msg = '%s - %s\n' % (dtfmt(datetime.now()), msg)
    fileio.append_text(msg, filename)
    print(msg.strip('\n'))

def logprint_nots(filename, msg):
    """Print to log file and console, no timestamp.
    """
    msg = '%s\n' % msg
    fileio.append_text(msg, filename)
    print(msg.strip('\n'))

def find_files(collection_path):
    """List files using git-annex-find.
    """
    return util.find_meta_files(
        collection_path, model='file', recursive=True, force_read=True
    )

def filter_files(files, roles):
    """Binary and access files for each File in roles
    """
    to_copy = []
    for path_rel in files:
        oi = identifier.Identifier(path_rel, config.MEDIA_BASE)
        role = oi.idparts.get('role')
        if role and (role in roles):
            o = oi.object()
            to_copy.append(o.path_rel)
            to_copy.append(o.access_rel)
    return sorted(list(set(to_copy)))

def rsync_files(to_copy, collection_path, destdir, LOG):
    os.chdir(collection_path)
    errs = []
    for f in to_copy:
        src = os.path.join(collection_path, f)
        src = f
        dest = os.path.join(destdir, f)
        cmd = 'rsync --copy-links %s %s/' % (src, destdir)
        logprint(LOG, cmd)
        r1 = envoy.run(cmd)
        if r1.status_code:
            logprint(LOG, 'STATUS {}'.format(r1.status_code))
            errs.append(src)
    return errs


def main():

    parser = argparse.ArgumentParser(description=description, epilog=epilog,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('collection', help='Absolute path to source collection repository.')
    parser.add_argument('destbase', help='Absolute path to destination base directory.')
    parser.add_argument('-m', '--mezzanine', action='store_const', const=1, help='git-annex copy mezzanine files.')
    parser.add_argument('-t', '--transcript', action='store_const', const=1, help='git-annex copy transcript')
    parser.add_argument('-A', '--administrative', action='store_const', const=1, help='git-annex administrative files.')
    parser.add_argument('-M', '--master', action='store_const', const=1, help='git-annex copy master files.')
    args = parser.parse_args()
    
    # check args
    if args.destbase == args.collection:
        print('ddrfilter: error: Source and destination are the same!')
        sys.exit(1)
    if not (args.mezzanine or args.transcript or args.administrative or args.master):
        print('ddrfilter: error: No file type(s) selected!')
        sys.exit(1)
    
    started = datetime.now()
    LOG = os.path.join(args.destbase, 'ddr-pubcopy.log')
    
    cid = os.path.basename(args.collection)
    destdir = os.path.normpath(os.path.join(args.destbase, cid))
    # if collection dir doesn't exist in destdir, mkdir
    if not os.path.exists(destdir):
        os.makedirs(destdir)
    
    logprint(LOG, 'Source      %s' % args.collection)
    logprint(LOG, 'Destination %s' % destdir)

    roles = []
    if args.mezzanine:      roles.append('mezzanine')
    if args.transcript:     roles.append('transcript')
    if args.administrative: roles.append('administrative')
    if args.master:         roles.append('master')
    logprint(LOG, 'Copying {}'.format(', '.join(roles)))
    
    files = find_files(args.collection)
    to_copy = filter_files(files, roles)
    errs = rsync_files(to_copy, args.collection, destdir, LOG)
    if errs:
        logprint(LOG, '%s FAILS:' % len(errs))
        for path in errs:
            logprint(LOG, path)
    
    finished = datetime.now()
    elapsed = finished - started
    logprint(LOG, 'DONE!')
    logprint_nots(LOG, '%s elapsed' % elapsed)
    print('')

if __name__ == '__main__':
    main()
